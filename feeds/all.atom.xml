<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Cheng's Blog</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2014-10-01T22:00:00+08:00</updated><entry><title>图像识别</title><link href="/.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:.html</id><summary type="html">&lt;h2&gt;图像检索的相关背景&lt;/h2&gt;
&lt;p&gt;从难易程度和发展顺序,不同的研究方向上大致上可以将图像检索划分为这么几个阶段&lt;br /&gt;
1. 基于文本的关键字搜索图像（CBIR） – 淘宝: 搜索”帽子”, 得到与帽子相关的图片产品&lt;br /&gt;
2. 基于内容的图像搜索（TBIR） – 淘宝：输入你喜欢的图片, 找到同款的产品&lt;br /&gt;
3. 基于语义的图像检索/图像识别 – 淘宝: 随手拍下喜欢帽子的图片, 通过搜索就能够找到同款或相似的额产品&lt;/p&gt;
&lt;h2&gt;阶段一 基于文本关键字搜索图像 (Text-based Image Retrieval)&lt;/h2&gt;
&lt;p&gt;相对普通的用例，用户输入文本关键字, 根据预定义的索引, 查找相对应的图片&lt;br /&gt;
1. 特征类别分化，图片库 --&amp;gt; 图片特征库 --&amp;gt; 关键字 类别 输入 匹配 检索结果
没有太多可以讨论的, 关键在于根据图片建立反向关键词索引的过程.&lt;/p&gt;
&lt;h2&gt;阶段二 反向图像搜索/基于内容的图像搜索 (Reverse Image Search /content-based image retrieval)&lt;/h2&gt;
&lt;p&gt;基于内容的图像检索技术利用图像本身就有的物理信息，通过对图像的颜色、纹理、形状和空间位置等特征进行比较，在一些特定的领域得到了大量的应用。 
从程序过程上来看， 可以分为如下： 图片特征值提取 --&amp;gt; 图片特征库 --&amp;gt; 待识别图片 特征提取 匹配 检索结果。&lt;br /&gt;
目前图像识别搜索采用的算法大都直接使用或者借鉴了SIFT， 通过定义一些的特征点或者说是指纹（颜色，纹理，形状特征）来取得图像文件的特征值。图片指纹并不能达到图片在视觉上的相似性搜索，当然它可适用于比较精准的搜索.  &lt;/p&gt;
&lt;h5&gt;罗列下常见的算法：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;SIFT(Scale-invariant feature transform), Lowe, 1999 -- 分析提取图像中的向量特征点进行匹配  &lt;/li&gt;
&lt;li&gt;PCA-SIFT(Principle Component Analysis)  &lt;/li&gt;
&lt;li&gt;SURF(Speeded Up Robust Features)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;一些基于反向搜索的商业案例:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;http://tineye.com – 基于图片的指纹&lt;/li&gt;
&lt;li&gt;http://www.tiltomo.com -- flickr 主题风格的色调和机制&lt;/li&gt;
&lt;li&gt;http://www.incogna.com -- 色彩和形状上的相似性&lt;/li&gt;
&lt;li&gt;http://www.terragalleria.com -- 视觉上的相似性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;阶段三 图像识别 (Image Recognition)&lt;/h2&gt;
&lt;p&gt;更为广泛的图像检索（也称这为基于内容的图像检索），是希望能返回与查询图像在视觉上相似的图像而非要一模一样的内容。 纯粹的逆向图片搜索， 只能帮助找到特征值逼近相同的图片， 并无法分类解释图片当中的具体内容。而更为高级的图片是要建立高层的语义特征而非简单的颜色、纹理、形状等低层特征。&lt;br /&gt;
Google利用了其原有的庞大的文本数据库， 为图像反查和文本搜索引擎的结合; 首先查询和原图相关的图片,再从全文搜索引擎猜测相关的内容。换句话说, 通过其web的上下文信息来反补了其原本不足的语义。&lt;br /&gt;
Google的方式：找到原图、认出图中是什么、找到类似的图、找到相关网页。
举个例子: 依据蘑菇的图片进行搜索&lt;/p&gt;
&lt;h5&gt;上图的内容分别为:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;找到原图&lt;/li&gt;
&lt;li&gt;认出图中是什么&lt;/li&gt;
&lt;li&gt;找到类似的图&lt;/li&gt;
&lt;li&gt;找到相关的网页&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思考一下此类方案的局限性 ，在于你用来搜索的原图片，是网上已有的，而不是自己拍摄的实物。试图在网上搜索出自己刚拍的一张照片里面究竟是什么东西，这种技术还处于极其原始的状态。&lt;br /&gt;
目前只能做到对照片中外观特征十分明显的对象做初步的模式识别，并辅以人工验证。
比如交通摄像头，对车牌这个方方正正的大蓝框和里面的大白字进行识别，然后让交警亲自比对，才能认定一个车牌号是否正确；&lt;br /&gt;
日常生活中更常见的二维码、条码、指纹识别、文字OCR，无一不是特征极其明显，而且拍摄时还要特意摆正对准。&lt;br /&gt;
换句话说,复杂图像的图像识别技术还处于很原始的阶段。  &lt;/p&gt;
&lt;h2&gt;综述&lt;/h2&gt;
&lt;p&gt;//todo&lt;/p&gt;
&lt;h2&gt;资料引用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;图像检索技术进展综述 -- 甘晨，易法令，王圆妹  长江大学计算机科学学院 434023&lt;/li&gt;
&lt;li&gt;http://en.wikipedia.org/wiki/Scale-invariant_feature_transform -- SIFT 基本介绍&lt;/li&gt;
&lt;li&gt;http://leafsnap.com/ --有意思的app, 拍摄植物的一枚叶子、花，果实或种子，app会分析告诉你这是什么植物。&lt;/li&gt;
&lt;li&gt;http://www.ipol.im/pub/pre/82/ -- The Anatomy of the SIFT Method&lt;/li&gt;
&lt;li&gt;//todo&lt;/li&gt;
&lt;/ol&gt;</summary><category term=""></category></entry><entry><title>CAP / BASE 理论</title><link href="/cap.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:cap.html</id><summary type="html">&lt;h2&gt;引用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed"&gt;CAP Twelve Years Later: How the "Rules" Have Changed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codahale.com/you-cant-sacrifice-partition-tolerance/"&gt;You Can’t Sacrifice Partition Tolerance&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Database"></category></entry><entry><title>JDK History</title><link href="/jdk-history.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:jdk-history.html</id><summary type="html">&lt;h2&gt;Timeline&lt;/h2&gt;
&lt;p&gt;&lt;img alt="JDK_history" src="img/JDK_history.png" /&gt;&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Java_version_history"&gt;Java version history&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Java"></category></entry><entry><title>JVM</title><link href="/jvm.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:jvm.html</id><summary type="html"></summary><category term="Java"></category></entry><entry><title>Markdown</title><link href="/markdown.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:markdown.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;一些Markdown 有用的链接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.jianshu.com/p/1e402922ee32"&gt;Markdown 简介&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://wowubuntu.com/markdown/"&gt;Markdown 语法 中文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mahua.jser.me/"&gt;一个在线编辑markdown文档的编辑器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://apple4us.com/2012/02/why-writers-should-use-markdown/"&gt;为什么作家应该用 Markdown 保存自己的文稿&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Markdown，标记语言"></category></entry><entry><title>PyMongo &amp; Mongodb Replica Set</title><link href="/mongo%20replica%20set%20and%20pymongo.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:mongo replica set and pymongo.html</id><summary type="html">&lt;p&gt;I have built up the MongoDB replica set could be used for some test.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Role&lt;/th&gt;
&lt;th&gt;PROPERTY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;HOST_A:PORT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SECONDARY&lt;/td&gt;
&lt;td&gt;HOST_B:PORT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SECONDARY&lt;/td&gt;
&lt;td&gt;HOST_C:PORT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;About Failover&lt;/h2&gt;
&lt;p&gt;From the perspective of Mongo side, the replica set will attempt to select another member to become the new primary.&lt;br /&gt;
From the perspective of a client application, whether a MongoDB instance is running as a single server (i.e. “standalone”) or a replica set is transparent.&lt;br /&gt;
However when a failover occurs, PyMongo will automatically attempt to find the new primary node and perform subsequent operations on that node, this can’t happen completely transparently.&lt;br /&gt;
After change origin client settings to :  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mongo = MongoClient([&amp;#39;C0043950.itcs.hp.com:27017&amp;#39;,&amp;#39;C0045057.itcs.hp.com:27017&amp;#39;,&amp;#39;c0045576.itcs.hp.com:27017&amp;#39;],replicaSet=&amp;#39;rs-1&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When failover happens (for example: PRIMARY node change from C0043950 to C0045057 after the election), transition will happen after an Error throwed.&lt;br /&gt;
1.  Connection will throw   &lt;code&gt;AutoReconnect Error&lt;/code&gt;&lt;br /&gt;
    Browser page will get 500 response.&lt;br /&gt;
2.  Refresh the page next time , PyMongo will automatically attempt to switch to the primary node. So the reply will be right.  &lt;/p&gt;
&lt;p&gt;References:&lt;br /&gt;
1. &lt;a href="http://stackoverflow.com/questions/26063346/in-pymongo-given-a-mongos-what-is-the-difference-between-normal-and-rs-clients/26387515#26387515"&gt;What is the difference between normal and RS clients&lt;/a&gt;  &lt;br /&gt;
2. &lt;a href="http://api.mongodb.org/python/current/examples/high_availability.html#handling-failover"&gt;Handing-failover&lt;/a&gt; &lt;br /&gt;
3. &lt;a href="http://api.mongodb.org/python/current/examples/high_availability.html#mongoreplicasetclient"&gt;might consider using MongoReplicaSetClient if necessary.&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;About Consistency&lt;/h2&gt;
&lt;p&gt;Consistency of MongoDB is sometime called eventual consistency because the secondary member’s state will eventually reflect the primary’s state and but MongoDB cannot guarantee strict consistency for read operations from secondary members.&lt;br /&gt;
By default, in MongoDB, read operations to a replica set return results from the primary and are consistent with the last write operation.&lt;br /&gt;
Users may configure read preference on a per-connection basis to prefer that the read operations return on the secondary members. If clients configure the read preference to permit secondary reads, read operations can return from secondary members that have not replicated more recent updates or operations. When reading from a secondary, a query may return data that reflects a previous state.&lt;br /&gt;
Secondaries nodes apply operations from the primary node asynchronously. By applying operations after the primary, sets can continue to function without some members.   &lt;/p&gt;
&lt;p&gt;In some cases, we can use replication to increase read capacity. &lt;br /&gt;
Leverage through this “eventual consistency”, for some less important data (for example , Logs) we could adjust the Write Concern ensure faster performance rather than ensure persistence to the entire deployment. &lt;br /&gt;
1. First set the read preference could from Secondaries&lt;br /&gt;
&lt;code&gt;mongo = MongoClient("host:port",read_preference=ReadPreference.SECONDARY)&lt;/code&gt; &lt;br /&gt;
2. Then we will have the default write concern for the PyMongo instance.&lt;br /&gt;
&lt;code&gt;mongo.write_concern = {'w': 3, 'wtimeout': 1000}&lt;/code&gt;&lt;br /&gt;
3. For other specific operations that don’t need such consistency , we could add the w value explicitly.&lt;br /&gt;
&lt;code&gt;db.remove({'_id':ObjectId(id)}, w=1)&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;References:&lt;br /&gt;
1. &lt;a href="http://docs.mongodb.org/manual/applications/replication/"&gt;Replica Set Read and Write Semantics&lt;/a&gt;&lt;br /&gt;
2. &lt;a href="http://docs.mongodb.org/manual/reference/glossary/#term-read-preference"&gt;Read Preference&lt;/a&gt;&lt;br /&gt;
3. &lt;a href="http://docs.mongodb.org/manual/core/write-concern/"&gt;Write Concern&lt;/a&gt;&lt;br /&gt;
4. &lt;a href="http://docs.mongodb.org/manual/release-notes/drivers-write-concern/"&gt;Driver Write Concern&lt;/a&gt;  &lt;br /&gt;
5. &lt;a href="http://api.mongodb.org/python/current/api/pymongo/mongo_client.html#pymongo.mongo_client.MongoClient.write_concern"&gt;PyMongo write_concern&lt;/a&gt;    &lt;/p&gt;</summary><category term="MongoDB"></category><category term="Python"></category></entry><entry><title>NoSQL</title><link href="/nosql.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:nosql.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;SQL 充当了应用程序之间的一种集成机制，所有的应用程序都在操作内容一致的持久数据。 但是各种应用程序之间的结构和性能要求不尽相同，随着阻抗失衡问题凸显和对于大数据的不适应，逐渐催生出了NoSQL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;数据库发展的时间线&lt;/h2&gt;
&lt;p&gt;&lt;img alt="数据库时间线" src="数据库时间线.png" /&gt;&lt;/p&gt;
&lt;h2&gt;引用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;NoSQL Distilled -- by Pramond J, Martin Fowler&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Database"></category><category term="NoSQL"></category></entry><entry><title>Oracle Isolation</title><link href="/oracle-isolation.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:oracle-isolation.html</id><summary type="html"></summary><category term="Oracle"></category><category term="Isolation"></category></entry><entry><title>利用Pelican和Github建立博客</title><link href="/pelican%20and%20github.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:pelican and github.html</id><summary type="html">&lt;p&gt;Jekyll基于ruby,Pelican基于python&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install pelican
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;pip install Markdown
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;mkdir dir_name
cd dir_name
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;make publish
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;make serve
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Python"></category></entry></feed>