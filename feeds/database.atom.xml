<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Cheng's Blog</title><link href="/" rel="alternate"></link><link href="/feeds/database.atom.xml" rel="self"></link><id>/</id><updated>2014-10-01T22:00:00+08:00</updated><entry><title>CAP / BASE 理论</title><link href="/cap.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:cap.html</id><summary type="html">&lt;h2&gt;引用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed"&gt;CAP Twelve Years Later: How the "Rules" Have Changed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codahale.com/you-cant-sacrifice-partition-tolerance/"&gt;You Can’t Sacrifice Partition Tolerance&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Database"></category></entry><entry><title>PyMongo &amp; Mongodb Replica Set</title><link href="/mongo%20replica%20set%20and%20pymongo.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:mongo replica set and pymongo.html</id><summary type="html">&lt;p&gt;I have built up the MongoDB replica set could be used for some test.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Role&lt;/th&gt;
&lt;th&gt;PROPERTY&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;HOST_A:PORT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SECONDARY&lt;/td&gt;
&lt;td&gt;HOST_B:PORT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SECONDARY&lt;/td&gt;
&lt;td&gt;HOST_C:PORT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;About Failover&lt;/h2&gt;
&lt;p&gt;From the perspective of Mongo side, the replica set will attempt to select another member to become the new primary.&lt;br /&gt;
From the perspective of a client application, whether a MongoDB instance is running as a single server (i.e. “standalone”) or a replica set is transparent.&lt;br /&gt;
However when a failover occurs, PyMongo will automatically attempt to find the new primary node and perform subsequent operations on that node, this can’t happen completely transparently.&lt;br /&gt;
After change origin client settings to :  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mongo = MongoClient([&amp;#39;C0043950.itcs.hp.com:27017&amp;#39;,&amp;#39;C0045057.itcs.hp.com:27017&amp;#39;,&amp;#39;c0045576.itcs.hp.com:27017&amp;#39;],replicaSet=&amp;#39;rs-1&amp;#39;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When failover happens (for example: PRIMARY node change from C0043950 to C0045057 after the election), transition will happen after an Error throwed.&lt;br /&gt;
1.  Connection will throw   &lt;code&gt;AutoReconnect Error&lt;/code&gt;&lt;br /&gt;
    Browser page will get 500 response.&lt;br /&gt;
2.  Refresh the page next time , PyMongo will automatically attempt to switch to the primary node. So the reply will be right.  &lt;/p&gt;
&lt;p&gt;References:&lt;br /&gt;
1. &lt;a href="http://stackoverflow.com/questions/26063346/in-pymongo-given-a-mongos-what-is-the-difference-between-normal-and-rs-clients/26387515#26387515"&gt;What is the difference between normal and RS clients&lt;/a&gt;  &lt;br /&gt;
2. &lt;a href="http://api.mongodb.org/python/current/examples/high_availability.html#handling-failover"&gt;Handing-failover&lt;/a&gt; &lt;br /&gt;
3. &lt;a href="http://api.mongodb.org/python/current/examples/high_availability.html#mongoreplicasetclient"&gt;might consider using MongoReplicaSetClient if necessary.&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;About Consistency&lt;/h2&gt;
&lt;p&gt;Consistency of MongoDB is sometime called eventual consistency because the secondary member’s state will eventually reflect the primary’s state and but MongoDB cannot guarantee strict consistency for read operations from secondary members.&lt;br /&gt;
By default, in MongoDB, read operations to a replica set return results from the primary and are consistent with the last write operation.&lt;br /&gt;
Users may configure read preference on a per-connection basis to prefer that the read operations return on the secondary members. If clients configure the read preference to permit secondary reads, read operations can return from secondary members that have not replicated more recent updates or operations. When reading from a secondary, a query may return data that reflects a previous state.&lt;br /&gt;
Secondaries nodes apply operations from the primary node asynchronously. By applying operations after the primary, sets can continue to function without some members.   &lt;/p&gt;
&lt;p&gt;In some cases, we can use replication to increase read capacity. &lt;br /&gt;
Leverage through this “eventual consistency”, for some less important data (for example , Logs) we could adjust the Write Concern ensure faster performance rather than ensure persistence to the entire deployment. &lt;br /&gt;
1. First set the read preference could from Secondaries&lt;br /&gt;
&lt;code&gt;mongo = MongoClient("host:port",read_preference=ReadPreference.SECONDARY)&lt;/code&gt; &lt;br /&gt;
2. Then we will have the default write concern for the PyMongo instance.&lt;br /&gt;
&lt;code&gt;mongo.write_concern = {'w': 3, 'wtimeout': 1000}&lt;/code&gt;&lt;br /&gt;
3. For other specific operations that don’t need such consistency , we could add the w value explicitly.&lt;br /&gt;
&lt;code&gt;db.remove({'_id':ObjectId(id)}, w=1)&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;References:&lt;br /&gt;
1. &lt;a href="http://docs.mongodb.org/manual/applications/replication/"&gt;Replica Set Read and Write Semantics&lt;/a&gt;&lt;br /&gt;
2. &lt;a href="http://docs.mongodb.org/manual/reference/glossary/#term-read-preference"&gt;Read Preference&lt;/a&gt;&lt;br /&gt;
3. &lt;a href="http://docs.mongodb.org/manual/core/write-concern/"&gt;Write Concern&lt;/a&gt;&lt;br /&gt;
4. &lt;a href="http://docs.mongodb.org/manual/release-notes/drivers-write-concern/"&gt;Driver Write Concern&lt;/a&gt;  &lt;br /&gt;
5. &lt;a href="http://api.mongodb.org/python/current/api/pymongo/mongo_client.html#pymongo.mongo_client.MongoClient.write_concern"&gt;PyMongo write_concern&lt;/a&gt;    &lt;/p&gt;</summary><category term="MongoDB"></category><category term="Python"></category></entry><entry><title>NoSQL</title><link href="/nosql.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:nosql.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;SQL 充当了应用程序之间的一种集成机制，所有的应用程序都在操作内容一致的持久数据。 但是各种应用程序之间的结构和性能要求不尽相同，随着阻抗失衡问题凸显和对于大数据的不适应，逐渐催生出了NoSQL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;数据库发展的时间线&lt;/h2&gt;
&lt;p&gt;&lt;img alt="数据库时间线" src="数据库时间线.png" /&gt;&lt;/p&gt;
&lt;h2&gt;引用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;NoSQL Distilled -- by Pramond J, Martin Fowler&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Database"></category><category term="NoSQL"></category></entry><entry><title>Oracle Isolation</title><link href="/oracle-isolation.html" rel="alternate"></link><updated>2014-10-01T22:00:00+08:00</updated><author><name>Cheng</name></author><id>tag:,2014-10-01:oracle-isolation.html</id><summary type="html"></summary><category term="Oracle"></category><category term="Isolation"></category></entry></feed>